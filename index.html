<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>WASM test</title>
  <script  type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
  <script async type="text/javascript" src="csolver.js"></script>
  <script async type="text/javascript" src="jssolver.js"></script>
  <script async type="text/javascript" src="tests.js"></script>

  <script>
    let comparasion_info = [['size', 'C time', 'js time']]

    function _moveArrayToHeap(array) {
      const uiArray = new Uint8Array(array);
      const space = Module._malloc(uiArray.length * uiArray.BYTES_PER_ELEMENT); // Similar a C malloc
      Module.HEAPU8.set(uiArray, space); // Es HEAP8 porque es Uint8Array (dado el tipo del problema, es suficiente Uint8Array - no necesitamos mas de 8 bits)
      return space;
    }

    function _allocateValue(size) {
      return Module._malloc(1 * size);
    }

    function _readFromHeap(pointer, size) {
      return Module.HEAPU8.subarray(pointer, pointer + size);
    }

    function CSolve(arrayX, arrayY, arrayZ, obj, length) {
      let arrayOnHeapX;
      let arrayOnHeapY;
      let arrayOnHeapZ;
      let outputLengthPtr = _allocateValue(1); // Char size
      let outputLength;
      let resultWASM;
      let result = [];
      try {
        arrayOnHeapX = _moveArrayToHeap(arrayX);
        arrayOnHeapY = _moveArrayToHeap(arrayY);
        arrayOnHeapZ = _moveArrayToHeap(arrayZ);
        resultWASM = Module.ccall(
          'solver',
          'number',
          ['number', 'number', 'number', 'number', 'number', 'number'],
          [arrayOnHeapX, arrayOnHeapY, arrayOnHeapZ, obj, length, outputLengthPtr],
        );
        outputLength = _readFromHeap(outputLengthPtr, 1)[0];
        for (let i = 0; i < outputLength; i++) {
          result.push(_readFromHeap(resultWASM + (3*i), 3));
        }
        //console.log(result);
      } catch(e) {
        console.error(e);
      } finally {
        Module._free(arrayOnHeapX);
        Module._free(arrayOnHeapY);
        Module._free(arrayOnHeapZ);
        Module._free(outputLengthPtr);
        Module._free(resultWASM);
        return result
      }
    }

    var Module = {
      onRuntimeInitialized: function () {
        for(let size = 2; size < 300; size+=15){
          const {x,y,z,b} = maketest(size);
          const startC = new Date();
          let resultC = CSolve(x, y, z, b, size);
          const endC = new Date()
          //console.log(endC - startC)
          const startJs = new Date();
          let resultJs = jssolver(b, x, y, z);
          const endJs = new Date() 
          //console.log(endJs - startJs);
          comparasion_info.push([size, endC-startC, endJs-startJs])
        }
      },
    };
    console.log(comparasion_info)
    google.charts.load('current', {'packages':['corechart']});
    google.charts.setOnLoadCallback(drawChart);

    function drawChart() {
      var data = google.visualization.arrayToDataTable(
        comparasion_info
      );

      var options = {
        title: 'Wasm Performance',
        curveType: 'function',
        legend: { position: 'bottom' }
      };

      var chart = new google.visualization.LineChart(document.getElementById('curve_chart'));

      chart.draw(data, options);
    }


  </script>


</head>

<body>
  <div id="curve_chart" style="width: 900px; height: 500px"></div>
</body>

</html>
